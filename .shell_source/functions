##### --histrory search START-- ######
highlightsudo='se|sq|sudo'
highlightcom='vim|ssh|chown|chmod|configure|ls|sed|grep|mc'
highlightgnu='cat|tac|nl|od|base32|base64|basenc|fmt|pr|fold|head|tail|split|csplit|wc|sum|uniq|comm|ptx|tsort|cut|paste|join|tr|expand|unexpand|ls|dir|vdir|dircolors|cp|dd|mv|rm|shred|link|ln|mkdir|mkfifo|mknod|readlink|rmdir|unlink|chown|chmod|chgrp|touch|df|du|stat|sync|truncate|echo|printf|test|expr|tee|basename|dirname|pathchk|mktemp|realpath|pwd|logname|whoami|id|groups|users|who|date|arch|nproc|uname|hostname|hostid|uptime|chcon|runcon|chroot|env|nice|nohup|stdbuf|timeout|kill|pkill|sleep|factor|numfmt|seq|source'

## example search with tag :
# $user: vim /etc/apt/source.list #tag-vim_source-list
# $user: hi vim
# install colorex or delete string the end
hhgrepv='(grep.*|hi|hh|hhall|history|hhistory|hhuniq|plz|sr|hhnumuniq|hhlastuniq-grep|hhlastuniq|hhistory-uniq) '
hhgrepvfirst='^(hi|hh|hhall|history|hhistory|hhuniq|plz|sr|hhnumuniq|grep|hhlastuniq-grep|hhlastuniq|hhistory-uniq)'
hhlocalgrepv='^(hi|hh|hhall|history|hhistory|hhuniq|plz|sr|hhnumuniq|hhlastuniq-grep|hhlastuniq|hhisrtory-uniq)'

#search for tag-
hi() {
    if [ -n "$(whereis colorex |cut -d: -f2 |egrep '/bin|/sbin' |tr -d ' ')" ]
        then history |grep --color=always "tag-$@" |grep -wvE "${hhgrepv}" |tail -n60 |colorex -b '^....[0-9] |sed -E "s/$/\n/g"'
        else history |grep --color=always "tag-$@" |grep -wvE "${hhgrepv}" |tail -n60 |grep '^....[0-9]'
    fi
}

# search for all history and show 50 last
hh() {
    if [ -n "$(whereis colorex |cut -d: -f2 |egrep '/bin|/sbin' |tr -d ' ')" ]
        then history |grep --color=always -i "$@" |grep -wvE "${hhgrepv}" |tail -n60 |colorex -b '^....[0-9]'
        else history |grep --color=always -i "$@" |grep -wvE "${hhgrepv}" |tail -n60 |grep '^....[0-9]'
    fi
}

# search all history to master word
hhall() {
    if [ -n "$(whereis colorex |cut -d: -f2 |egrep '/bin|/sbin' |tr -d ' ')" ]
        then history |grep --color=always -i "$@" |grep -wvE "${hhgrepv}" |colorex -b '^....[0-9]'
        else history |grep --color=always -i "$@" |grep -wvE "${hhgrepv}" |grep '^....[0-9]'
    fi
}

# search all history and highlight special command
hhistory() {
    if [ -n "$(whereis colorex |cut -d: -f2 |egrep '/bin|/sbin' |tr -d ' ')" ]; then
        history |grep -wvE "${hhgrepv}" |colorex -b '^....[0-9]' |colorex -c ":[0-9][0-9] (${highlightgnu})" |colorex -y ":[0-9][0-9] (${highlightcom})" |colorex -B ":[0-9][0-9] (${highlightsudo}).*" |colorex -r '\|' |colorex -D '\|' |colorex -g '\/' |colorex -M '\\'
    else history |grep --color=always -wvE "${hhgrepv}" |grep '^....[0-9]'
    fi
}

# serach uniq word
hhuniq() {
    if [ -n "$(whereis colorex |cut -d: -f2 |egrep '/bin|/sbin' |tr -d ' ')" ]; then
        history |grep --color=always -i "$@" |awk "{\$1=\$2=\$3\"\"; print \$0}" |sed -E 's/^\s{8}//g' |sed 's/^\(\([0-9]\{2\}:\)\{2\}[0-9]\{2\}\s\)\{3\}//g' |grep -vE "${hhgrepvfirst}"|awk "!a[\$0]++" |colorex -c "^(${highlightgnu})" |colorex -y "^(${highlightcom})" |colorex -Y "^(${highlightsudo}).*" |colorex -r '\|' |colorex -D '\|' |colorex -g '\/' |colorex -M '\\'
    else
        history |grep --color=always -i "$@" |awk "{\$1=\$2=\$3\"\"; print \$0}" |sed -E 's/^\s{8}//g' |sed 's/^\(\([0-9]\{2\}:\)\{2\}[0-9]\{2\}\s\)\{3\}//g' |grep -vE "${hhgrepvfirst}"|awk "!a[\$0]++"
    fi
}

# search last uniq word from your past line numbers
# Example: hhlastuniq 50
hhlastuniq() {
    if [ -n "$(whereis colorex |cut -d: -f2 |egrep '/bin|/sbin' |tr -d ' ')" ]; then
        history |tail -n "$1" |awk "{\$1=\$2=\$3\"\"; print \$0}" |sed -E 's/^\s{8}//g' |sed 's/^\(\([0-9]\{2\}:\)\{2\}[0-9]\{2\}\s\)\{3\}//g' |grep -vE "${hhgrepvfirst}" |awk "!a[\$0]++" |colorex -c "^(${highlightgnu})" |colorex -y "^(${highlightcom})" |colorex -Y "^(${highlightsudo}).*" |colorex -r '\|' |colorex -D '\|' |colorex -g '\/' |colorex -M '\\'
    else
        history |tail -n "$1" |awk "{\$1=\$2=\$3\"\"; print \$0}" |sed -E 's/^\s{8}//g' |sed 's/^\(\([0-9]\{2\}:\)\{2\}[0-9]\{2\}\s\)\{3\}//g' |grep -vE "${hhgrepvfirst}" |awk "!a[\$0]++"
    fi
}

#C- use hhlastuniq-grep <50>
hhlastuniq-grep() {
    if [ -n "$(whereis colorex |cut -d: -f2 |egrep '/bin|/sbin' |tr -d ' ')" ]; then
        history |tail -n "$1" |awk "{\$1=\$2=\$3\"\"; print \$0}" |sed -E 's/^\s{8}//g' |sed 's/^\(\([0-9]\{2\}:\)\{2\}[0-9]\{2\}\s\)\{3\}//g' |grep -vE "${hhlocalgrepv}"  |awk "!a[\$0]++" |colorex -c "^(${highlightgnu})" |colorex -y "^(${highlightcom})" |colorex -Y "^(${highlightsudo}).*" |colorex -r '\|' |colorex -D '\|' |colorex -g '\/' |colorex -M '\\'
    else
        history |tail -n "$1" |awk "{\$1=\$2=\$3\"\"; print \$0}" |sed -E 's/^\s{8}//g' |sed 's/^\(\([0-9]\{2\}:\)\{2\}[0-9]\{2\}\s\)\{3\}//g' |grep -vE "${hhlocalgrepv}" |awk "!a[\$0]++"
    fi
}

# serach uniq word and nummber command
# search better thought first word in commnad
#     example : hhnumuniq bash
#     output - 1847  2019-08-28 18:35:53 bash /var/www/vtigercrm-SPAsteriskConnector/bin/start.sh

hhnumuniq() {
    declare -A unnumber
    local len="$(hhuniq "$@" |wc -l)"
    local criterion="$(history | grep --color=none -i "$@" |grep --color=none -wv "${hhgrepv}" |awk "{\$1=\$2=\$3\"\"; print \$0}" |sed -E 's/^\s{8}//g' |sed 's/^\(\([0-9]\{2\}:\)\{2\}[0-9]\{2\}\s\)\{3\}//g' |awk "!a[\$0]++")"
    local listprevent="$(history | grep --color=always -i "$@" |grep -wv "${hhgrepv}" |sed -E 's/^\s{4}//g' |awk "!a[\$0]++")"

    for i in $(seq $len); do
        local str=$(echo "$criterion" |sed "$i!d")
        local idx="$i"
        unnumber["$idx"]="${str:0}"
        local idnumber="${unnumber[$idx]}"
        local change="$(echo "$idnumber" |awk -v sec="$1.*" '{ $1="";  print sec$0; }')"
        echo -e "$listprevent" |/usr/bin/grep "${change}" |tail -n1
    done
}

hhistory-uniq() {
    if [ -n "$(whereis colorex |cut -d: -f2 |egrep '/bin|/sbin' |tr -d ' ')" ]; then
        history |awk "{\$1=\$2=\$3\"\"; print \$0}" |sed -E 's/^\s{8}//g' |sed 's/^\(\([0-9]\{2\}:\)\{2\}[0-9]\{2\}\s\)\{3\}//g' |grep -vE "${hhlocalgrepv}"  |awk "!a[\$0]++" |colorex -c "^(${highlightgnu})" |colorex -y "^(${highlightcom})" |colorex -Y "^(${highlightsudo}).*" |colorex -r '\|' |colorex -D '\|' |colorex -g '\/' |colorex -M '\\'
    else
        history |awk "{\$1=\$2=\$3\"\"; print \$0}" |sed -E 's/^\s{8}//g' |sed 's/^\(\([0-9]\{2\}:\)\{2\}[0-9]\{2\}\s\)\{3\}//g' |grep -vE "${hhlocalgrepv}" |awk "!a[\$0]++"
    fi
}

##### --histrory search END-- #####

incognito() {
  case $1 in
    start)
    set +o history;;
    stop)
    set -o history;;
    *)
    echo -e "USAGE: incognito start - disable command history.
       incognito stop  - enable command history.";;
  esac
}

extract () {
  if [ -f $1 ] ; then
      case $1 in
          *.tar.bz2)   tar xvjf $1    ;;
          *.tar.gz)    tar xvzf $1    ;;
          *.tar.xz)   tar -xpJf $1    ;;
          *.bz2)       bunzip2 $1     ;;
          *.rar)       rar x $1       ;;
          *.gz)        gunzip $1      ;;
          *.xz)        unxz $1        ;;
          *.tar)       tar xvf $1     ;;
          *.tbz2)      tar xvjf $1    ;;
          *.tgz)       tar xvzf $1    ;;
          *.zip)       unzip $1       ;;
          *.Z)         uncompress $1  ;;
          *.7z)        7z x $1        ;;
          *)           echo "don't know how to extract '$1'..." ;;
      esac
  else
      echo "'$1' is not a valid file!"
  fi
}

defcat() {
    if [ -x /bin/cat ]; then
        /bin/cat "$@"
    else /usr/bin/cat "$@"
    fi
}

# remove unprintable characters for output utilit "script"
# use - scriptformat input_file output_file
scriptformat() {
    local defaultcat=$(whereis cat |cut -d: -f2 |egrep '/bin|/sbin' |tr -d ' ')
    ${defaultcat} $1 | perl -pe 's/\e([^\[\]]|\[.*?[a-zA-Z]|\].*?\a)//g' | col -bp > $2
}

#C- color highlight output
gulimit() { ulimit "$@" |grcat conf.ulimit ; }
gconfigure() { configure "$@" |grcat conf.configure; }
se() { /usr/bin/sudo HOME=$HOME "$@"; }
mmake() { /usr/bin/make "$@" |colorex -c '(?i)making all.*' -y '(?i)making install.*' -R '(?i)error.*' -M '(?i)warning.*'; }
cconfigure() { ./configure "$@" |colorex -c ' not found' -g ' found' -c ' no' -g ' yes' -R '(?i)error`' -M '(?i)warning' -Y ' (?i)no support'; }
ccolorex() { /usr/bin/colorex "$@" -R '(?i)err' -M '(?i)warn'; -g '(?i)done' -r '(?i)failed'; }

#C- create archive
function maketar() { tar cvzf "${1%%/}.tar.gz"  "${1%%/}/"; }   # Creates an archive (*.tar.gz) from given directory
function makezip() { zip -r "${1%%/}.zip" "$1" ; }              # Create a ZIP archive of a file or folder.

#C- use - cht /ls/
cht() { /usr/bin/curl cheat.sh/"$@"; }

#C- systemd status
sys-start() { sudo bash -c "sudo systemctl start $*"; sudo systemctl status $* --full --no-pager; }
sys-stop() { sudo bash -c "systemctl stop $*"; sudo systemctl status $* --full --no-pager; }
sys-reload() { sudo bash -c "systemctl reload $*"; sudo systemctl status $* --full --no-pager; }
sys-restart() { sudo bash -c "systemctl restart $*" && sleep 2 && sudo systemctl status $* --full --no-pager; }
sys-stat() { sudo bash -c "systemctl status $* --full --no-pager"; }
sys-list() { sudo bash -c "systemctl list-units '*$1*' --full --no-pager"; }
sys-sock() { sudo bash -c "systemctl list-sockets '*$1*' --full --no-pager"; }
sys-cat() { sudo bash -c "systemctl cat $* --full --no-pager"; }
sys-edit() { sudo bash -c "sudo EDITOR=vim systemctl edit $*"; }
sys-enable() { sudo bash -c "systemctl enable $*"; }
sys-disable() { sudo bash -c "systemctl disable $*"; }
sys-daemon() { sudo bash -c "systemctl daemon-reload"; }
sysstopstart() {
    sudo bash -c "systemctl stop $*" && sleep 1 &&
    sudo systemctl start $* && sleep 3 &&
    sudo systemctl status $* --full --no-pager
}

#C- check used memory/or..
check_mem_humanreadable() { ps aux | awk '{print $6/1024 " MB\t\t" $11}' | sort -n |tail |column -t; }
check_mem_procent() { ps -e -o pid,user,%mem,command --sort %mem; }
check_mem() { ps -e -o pid,vsz,comm= | sort -n -k 2; }
check_swap() {
    for dir in $(find /proc/ -maxdepth 1 -type d |grep -E "[0-9]+"); do
        local pid=$(echo $dir |cut -d/ -f3)
        local cmd=$(ps h -o comm -p $pid)
        local swap=$(grep VmSwap ${dir}/status 2> /dev/null |awk '{print int($2/1024)}')
        if [ ! -z $swap ] && [ $swap -ne 0 ]; then
            echo "pid: $pid command: $cmd swap: $swap MB"
        fi
    done |sort -rnk6 |column -t
}

vime() { xargs sh -c 'vim "$@" < /dev/tty' example; } ## or use "xarg -o vim", #example - any word

ports() {
    local check_netstat=$(type netstat)
    local sudo_used=''

    if $(sudo -v); then sudo_used='sudo'; fi

    if [ -n "$check_netstat" ]
        then ${sudo_used} netstat -tulpn |sort -t: -k2 -n
        else ${sudo_used} ss -tulpn |sort -t: -k2 -n |sed -E 's/users:\(\(([^,]+),pid=([0-9]+).*?\)\).*/users:(\1, pid=\2)/'
    fi
}

allcrontab() {
    local red='\e[0;31m'
    local RED='\e[1;31m'
    local green='\e[0;32m'
    local GREEN='\e[1;32m'
    local PURPLE='\e[1;35m'
    local YELLOW='\e[22;33m'
    local NC='\e[0m'

    local cron_dir="$(find /etc -type d -name "*cron*" 2> /dev/null)"

    for dir in $cron_dir; do
        echo -e "----------------- ${PURPLE}START ${dir} -------------------- ${NC}\n"
            for crond in $(ls -L1 $dir); do
                if $(sudo -v)
                    then crondtab=$(sudo sh -c "cat ${dir}/${crond} 2>/dev/null" |egrep -Ev "^\s*(;|#|$)")
                    else crondtab=$(cat "${dir}/${crond}" 2>/dev/null |egrep -Ev "^\s*(;|#|$)")
                fi

                if [ -n "${crondtab}" ]; then
                    echo -e "${RED}====== Start ${dir}/ ${NC}${GREEN}${crond}${NC} ${RED}======${NC}"
                        echo "${crondtab}"
                    echo -e "${RED}====== End ${crond} ${NC}${GREEN}${crond}${NC} ${RED}======${NC}\n"
                fi
            done
        echo -e "----------------- ${PURPLE}END ${dir} -------------------- ${NC}\n"
    done

    echo -e "----------------- ${PURPLE}START /etc/crontab -------------------- ${NC}\n"
        cat /etc/crontab |egrep -Ev "^\s*(;|#|$)"
    echo -e "----------------- ${PURPLE}END /etc/crontab -------------------- ${NC}\n"

    echo -e "----------------- ${PURPLE}START users crontab -------------------- ${NC}\n"
        if $(sudo -v &> /dev/null); then
            for user in $(cut -d':' -f1 /etc/passwd); do
                local usercrontab=$(sudo sh -c "crontab -l -u ${user} 2>/dev/null")

                if [ -n "${usercrontab}" ]; then
                    echo -e "${RED}====== Start crontab for user ${NC}${GREEN}${user}${NC} ${RED}======${NC}"
                        sudo sh -c "crontab -l -u ${user}" |sed '/ *#/d; /^ *$/d'
                    echo -e "${RED}====== End crontab for user ${NC}${GREEN}${user}${NC} ${RED}========${NC}\n"
                fi
            done
        else
            echo -e "${YELLOW}====== Start crontab for user ${NC}${GREEN}${user}${NC} ${YELLOW}======${NC}"
                crontab -l |sed '/ *#/d; /^ *$/d'
            echo -e "${YELLOW}====== End crontab for user ${NC}${GREEN}${user}${NC} ${YELLOW}========${NC}\n"
        fi
    echo -e "----------------- ${PURPLE}END users crontab -------------------- ${NC}\n"

}


checkSizeInDirWithIgnore() {
#C- example: checkSizeInDirWithIgnore var boot
#or         checkSizeInDirWithIgnore
    local params=''
    local with=false
    if [ "$1" = '--with-proc' ]
        then with=true
        else params="-I proc -I sys -I dev"
    fi

    if [ "$#" -lt 1 ]
        then params="$params -I mnt "
        elif [ "$#" -gt 1 ]; then

            if [ "$with" = true ]
                then item_no=2
                else item_no=1
            fi

            local count="$#"
            for ((i=$item_no; i <= $count; i++)); do
                param="${!i}"
                params="$params -I $param "
            done
        else params+=" -I $1"
    fi

    local list="$(ls -a $params |egrep -v '^(\.\.|\.)$')"
    if $(sudo -v); then
        echo -e "this directory - \033[1;36m $(pwd) \033[0m"
        sudo du -sh $list |sort -hr; else
        du -sh $list      |sort -hr
    fi
}


removeComments() {
#C- Used: removeComments /path/to/file '\;'
#or       removeComments /path/to/file
#TODO ADD EXCLUDE SPECIFIC
    local run=false
    local removed='#'
    local path="$1"

    if [ "$#" -lt 1 ]; then
       echo -e "Error: no arguments, must will be min - 1"
    elif [ "$#" -gt 2 ]; then
       echo -e "Error: too many arguments, must will be max - 2"
    else
        run=true

        if [ "$#" -eq 2 ]; then
            if [ "$2" != '' ];  then removed="$2"; fi
            if [ "$2" != ' ' ]; then removed="$2"; fi
        fi
    fi

    if [ "$run" = true ]; then
        if $(sudo -v); then
            sudo cat "$path" |egrep -v "^${removed}|^\s?+${removed}|^$" |sed "s/${removed}.*//g" |sed '/^$/d' |grep -v '^\s*$'
        else
            cat "$path" |egrep -v "^${removed}|^\s?+${removed}|^$" |sed "s/${removed}.*//g" |sed '/^$/d' |grep -v '^\s*$'
        fi
     fi
}

egreplessdir() {
#C- Example: egreplessdir  'struing' /path/to/dir '\string_exclude_comment' '--<param>'
#or          egreplessdir  'string pattern' /path/to/dir
#TODO ADD IGNORE
    local run=false
    local comment='#'
    local path="$2"
    local pattern="$1"
    local param=''

    if [ "$#" -le 1 ]; then
       echo -e "Error: too few arguments, must will be min - 2"
    elif [ "$#" -gt 4 ]; then
       echo -e "Error: too many arguments, must will be max - 4"
    else
        run=true

        if [ "$#" -ge 3 ]; then
            if [ "$3" != '' ];  then comment="$3"; fi
            if [ "$3" != ' ' ]; then comment="$3"; fi
        fi

        if [ "$#" -eq 4 ]; then param="$4"; fi
    fi


    if [ "$run" = true ]; then
        if [ "$param" = '--binary' ]; then
            grep -o ".\{0,120\}${pattern}.\{0,120\}" -ir "$path" |egrep -v "^${comment}|^\s?+${comment}" \
                            |sed "s/\(:${comment}\).*/ -_CLEARED_by_filter_-/g" |grep -i "$pattern";    else
            grep -o ".\{0,120\}${pattern}.\{0,120\}" -iIr "$path" |egrep -v "^${comment}|^\s?+${comment}" \
                            |sed "s/\(:${comment}\).*/ -_CLEARED_by_filter_-/g" |grep -i "$pattern"
        fi
    fi
}

egrepless() {
#C- Example: egrepless  'struing' /path/to/file '\string_comment' '--<param>'
#or             egrepless  'string pattern' /path/to/file
    local run=false
    local comment='#'
    local path="$2"
    local pattern="$1"
    local param=''

    if [ "$#" -le 1 ]; then
       echo -e "Error: too few arguments, must will be min - 2"
    elif [ "$#" -gt 4 ]; then
       echo -e "Error: too many arguments, must will be max - 4"
    else
        run=true

        if [ "$#" -ge 3 ]; then
            if [ "$3" != '' ];  then comment="$3"; fi
            if [ "$3" != ' ' ]; then comment="$3"; fi
        fi

        if [ "$#" -eq 4 ]; then param="$4"; fi
    fi


    if [ "$run" = true ]; then
        if [ "$param" == '--num' ]; then
            grep -o ".\{0,150\}${pattern}.\{0,150\}" -i "$path"  |egrep -v "^${comment}|^$\s?+${comment}" |grep -in "$pattern"; else
            grep -o ".\{0,150\}${pattern}.\{0,150\}" -i "$path"  |egrep -v "^${comment}|^$\s?+${comment}" \
                                |sed "s/\(:${comment}\).*/ -_CLEARED_by_filter_-/g" |grep -in "$pattern"
        fi
    fi
}


diffFiles() {
    diff --color --unified=0 $1 $2
}

showCountOpenFiles () {
#C- example: showCountOpenFiles apache2 ## or showCountOpenFiles 781 ## ppid=781
    if $(sudo -v); then
        local srv_app=$1

        if [ -n "$srv_app" ]; then input=1 ; else
            echo -e "\n \033[0;32m please enter service name or parent pid :\033[0m"
            if read -t 360 -sp "" input; then
                echo -e "you inputed \n $input\n"
                srv_app=$input
            fi
        fi

        local check_name="$(echo $srv_app |grep '^.*[A-Za-z].*')"
        local check_num="$(echo $srv_app |grep '^[0-9]*[0-9]$')"


        if [ -n "$check_name" ]; then
            local Ppid=$(ps -o ppid= -p "$(pidof $srv_app -s)" |tr -d ' ')
        fi

        if [ -n "$check_num" ]; then Ppid=$srv_app; fi

        #ppid != 1
        if [[ "$Ppid" != 1 &&  "$Ppid" != 0 && "$Ppid" =~ ^[0-9]+$ ]]; then

            local list_pid=$(sudo pstree -p "$Ppid" -n |awk -F '|-' '{print $2}' |cut -d '(' -f2 |tr -d '()+' |grep -v '^$')
            local f=$(sudo ls -l /proc/${Ppid}/fd |wc -l)
            echo "files opened in Parent pid ${Ppid} - $f"
            local sum=$(expr 0 + $f)

            for cpid in $list_pid; do
                f=$(sudo ls -l /proc/${cpid}/fd 2> /dev/null |wc -l)
                echo "files opened in child pid ${cpid} - $f"
                sum=$(expr $sum + $f)
            done

            echo -e "summarize files opened -\033[0;35m $sum \033[0m"

        else
            echo -e "\033[1;31m Parent pid dont't be euqal 1/0 or content alphabic symbols;\033[0m ppid =$Ppid; you inputed - $srv_app"
        fi
    else
        echo -e "\033[1;31m You don't have sudo priveleges"
    fi
}

rm() {
    if [[ "$*" == *"-rf"* ]]; then
        local all_arg="$@"
        echo "Do you really want to Totally/Fully delete/remove the directory/ies 'rm -rf'? (y/n)"
        read -t 60 -r answer

        if [ "$answer" = 'y' ]; then
            echo "A you shure 'rm' ${all_arg} ? (y/n)"
            read -t 60 -r finish_answer
            if [ "$finish_answer" = 'y' ]
                then /bin/rm -rf "$@"
                else echo "Cancel"
            fi
        else
            echo "Cancel"
        fi
    else
        /bin/rm "$@"
    fi
}

function move_cursor_to_end_line () {
    local columns=$(tput cols)      #get length line
    local preend=$(( $columns - 8 ))
    echo "\033[${preend}G"
}

function show_new_files() {
# TODO add range search times
# TODO add --help or -h
# TODO add naming log install #use arrat for case *
    local change_time=true
    local sort_name=true
    local root_tree=true
    local no_shares=true
    local no_create=false
    local modify_time=false
    local sort_time=false
    local curr_dir=false
    local include_all_dirs=false

    local minits=60
    local DATE="$(date +%F)"
    local TIME="$(date +%Hh-%Mm-%Ss)"
    local out_path="/tmp/new_files/${DATE}"
    local print_args=''
    local sort_args=''
    local sudo_used=''
    local comamnd_output=''
    local new_cat=''
    local echo_console=''
    local start_exclude_path="-path /tmp/new_files"
    local exclude_paths=''
    local exclude_shares="-o -path /mnt"
    local exclude=''
    local last_history=''
    local hist_exclude=''
    local all_cli_args="$*"


    if [ -n "$1" ]; then
        if [[ "$1" =~ ^[0-9]+$ ]]; then
            minits=${1}
        fi
    fi

    if [[ $EUID -ne 0 ]]; then
        if $(sudo -v);
            then sudo_used='sudo'
        fi
    fi


        # check parameters
    while [[ "$#" -gt 0 ]]; do
        case $1 in
            --no-create) no_create=true ;;
            --modify-time) modify_time=true; change_time=false ;;
            --sort-time) sort_time=true; sort_name=false ;;
            --dir) curr_dir=true; root_tree=false ;;
            --exclude=*) exclude="${1#*=}" ;;
            --share) no_shares=false ;;
            --all) include_all_dirs=true; no_shares=true ;;
            *)
                #ignore
                ;;
        esac
        shift
    done

        # show that time
    if $change_time; then
        print_args="%Cd-%Cm-%CY %CH:%CM:%CS %s\t %p %m %u:%g [%i]\n"
    elif $modify_time; then
        print_args="%Td-%Tm-%TY %TH:%TM %s\t %p %m %u:%g [%i]\n"
    fi

        # sort options
    if $sort_name; then
        sort_args="-k4"
    elif $sort_time; then
        sort_args="-k1.7,1.10r -k1.4,1.5r -k1.1,1.2r -k2.1r -k2.2r -k2.4r -k2.5r -k2.7r -k2.8r -k2.10r -k2.11r -k2.12r"
    fi

        # exclude options
    if [ -n "$exclude" ]; then
        for i in ${exclude}; do
            exclude_paths="${exclude_paths} -o -path ${i}"
        done
    fi

        # search path
    if $root_tree; then
        search_path='/'
    elif $curr_dir; then
        search_path='.'
    fi

        # show all paths
    if $include_all_dirs; then
        exclude_def=""
    else
        exclude_def="-o -path /proc
            -o -path /sys
            -o -path /dev
            -o -path /run
            -o -path /var/lib/docker
            -o -path '*/.git'
        "
    fi

        # exclude share fs in paths
    if $no_shares; then
        shares="$(df -hT |egrep 'cifs|nfs|9p' |awk '{print $7}')"
        if [ -n "$shares" ]; then
            for i in ${shares}; do
                exclude_shares="${exclude_shares} -o -path ${i}"
            done
        fi
    else exclude_shares=''
    fi

        # don't create log
    if $no_create; then
        command_output="cat"
    else
        if [ ! -d ${out_path} ]; then mkdir -p ${out_path}; fi
        check_tee=$(type -P tee)
        if [[ $? == 0 ]];
            then new_cat='tee -a'
            else new_cat='cat >> '
        fi
        hist_exclude='^(#|vi?m|cat|head|tail|source|lla|ll|less|more|show_new_file|show_changed_files|git\ (log|commit|reset|status|pull|set|fetch|branch|switch))'
        last_history=$(
          tail "${HOME}/.bash_history" -n 200 |
          awk '
            {
              if ($1 ~ /^[0-9]/) {
                for (i = 4; i <= NF; i++) {
                  printf "%s%s", $i, (i < NF ? OFS : ORS)
                }
              } else {
                print $0
              }
            }
          ' |
          egrep -v "${hist_exclude}|${hhlocalgrepv}|^$" |
          tail -n10
        )

        echo -e "${all_cli_args} \n ${last_history} \n " >> ${out_path}/changed_from_${TIME}_last_${minits}_min
        command_output="$new_cat ${out_path}/changed_from_${TIME}_last_${minits}_min"
        echo_console="saved output in ${out_path}/changed_from_${TIME}_last_${minits}_min"
    fi

    ${sudo_used} find ${search_path} -type d  \( ${start_exclude_path} ${exclude_def} \
                        ${exclude_shares} ${exclude_paths} \
                    \) -prune \
                    -o -type f -cmin -${minits} \
                    -printf "${print_args}" \
    |awk '{
        $2 = substr($2, 1, 12);
        if (length($3) >= 3 && length($3) < 6) {
           $3 = sprintf("\t%.2fkb\t", $3/1024);
        } else if (length($3) >= 6 && length($3) < 10) {
           $3 = sprintf("\t%.2fmb\t", $3/1024/1024);
        } else if (length($3) >= 10 && length($3) < 13) {
           $3 = sprintf("\t%.2fgb\t", $3/1024/1024/1024);
        } else if (length($3) >= 13) {
           $3 = sprintf("\t%.2ftb\t", $3/1024/1024/1024/1024);
        } else {
           $3 = "\t"$3 "b""\t";
        }
        $4=$4 "\t " ;
        print
    }' \
    |sort ${sort_args} \
    |eval "$( echo ${command_output} )"
    echo -e "\n\033[0;32m ${echo_console} \033[0m"

#| **Sort Key**      | **Description**                                                                     |
#|-------------------|-------------------------------------------------------------------------------------|
#| `-k1.7,1.10r`     | Reverse sort by characters 7 to 10 in the first column                              |
#| `-k1.4,1.5r`      | Reverse sort by characters 4 to 5 in the first column                               |
#| `-k1.1,1.2r`      | Reverse sort by characters 1 to 2 in the first column                               |
#| `-k2.1r`          | Reverse sort by the 1st character of the second column                              |
#| `-k2.2r`          | Reverse sort by the 2nd character of the second column                              |
#| `-k2.4r`          | Reverse sort by the 4th character of the second column                              |
#| `-k2.5r`          | Reverse sort by the 5th character of the second column                              |
#....

}

show_changed_files() {
    local search_path='.'
    local start_exclude_path="-path /tmp/new_files"
    local exclude_paths=''
    local sudo_used=''
    local row_lenght=25
    local iso_format='long-iso'
    local nocolumn=false
    local column="eval column -t"
    local exclude=''
    local old_sort=false
    local sort_date="eval sort -nr"
    local create=false
    local DATE="$(date +%F)"
    local DATETIME="$(date +%F_%Hh-%Mm)"
    local out_path="/tmp/new_files/${DATE}"
    local echo_console=''
    local all_cli_args="$*"

    if [ -n "$1" ]; then
        if [[ "$1" != 'help' ]] \
        && [[ ! "$1" =~ ^-- ]] \
        && [[ "$1" != '-h' ]]
            then search_path="$1"
        fi
    fi

    if [[ $EUID -ne 0 ]]; then
        if $(sudo -v);
            then sudo_used='sudo'
        fi
    fi

    while [[ "$#" -gt 0 ]]; do
        case $1 in
            --head=[0-9]*) row_lenght="${1#*=}" ;;
            --lenght=[0-9]*) row_lenght="${1#*=}" ;;
            --nocolumn) nocolumn=true ;;
            --date-format=*) iso_format="${1#*=}" ;;
            --exclude=*) exclude="${1#*=}" ;;
            --old) old_sort=true ;;
            --create) create=true ;;
            *)
                #ignore
                ;;
        esac
        shift #unset $1, and set new $1
    done

    if $nocolumn; then
        column="eval sed 's/ /\t/'"
    fi

        #exclude options
    if [ -n "$exclude" ]; then
        for i in ${exclude}; do
            echo $i
            exclude_paths="${exclude_paths} -o -path ${i}"
        done
    fi

        #show older on start
    if $old_sort; then
        sort_date="eval sort -n"
    fi

    if $create; then
        if [ ! -d ${out_path} ]; then mkdir -p ${out_path}; fi
        check_tee=$(type -P tee)
        if [[ $? == 0 ]];
            then new_cat='tee -a'
            else new_cat='cat >> '
        fi
        echo -e "${all_cli_args} \n ${PWD} \n " >> ${out_path}/check_change_on_${DATETIME}
        command_output="$new_cat ${out_path}/check_change_on_${DATETIME}"
        echo_console="saved output in ${out_path}/check_change_on_${DATETIME}"
    else
        command_output="cat"
    fi

    ${sudo_used} find ${search_path} -type d  \( ${start_exclude_path} \
                    ${exclude_paths} \) -prune \
                    -o -type f -exec stat -c '%Z %n' {} \; \
    |${sort_date}  |head -n${row_lenght} |cut -d' ' -f2- \
    |${sudo_used} xargs -I{} ls -lhtc --time-style=${iso_format} -- {} \
    |${column} \
    |eval "$( echo ${command_output} )"
    echo -e "\n\033[0;32m ${echo_console} \033[0m"
}

addBackup() {
    local backup_path="${PWD}/${1}"
    local check_type="$(file -b ${backup_path})"
    sudo_used=''
    local num=0
    local check_num=0
    local check_zstd=''

    if [[ $EUID -ne 0 ]]; then
        if $(sudo -v);
            then sudo_used='sudo'
        fi
    fi

    if [ "$check_type" = "directory" ]
        then
            check_previous="$(2>/dev/null ls -a ${backup_path}_[0-9]* |egrep '\.(gz|zst)' 2> /dev/null)"
            if [ -n "$check_previous" ]; then
                check_num=$(echo "$check_previous" |wc -l)
            fi
            num=$(expr $check_num + 1)
            check_zstd="$(type -P zstd)"
            if [ -n "$check_zstd" ]
                then ${sudo_used} tar -I "zstd -12 -T0" -cf ${backup_path}_${num}.tar.zst ${backup_path}
                else ${sudo_used} tar czfp ${backup_path}_${num}.tar.gz ${backup_path}
            fi
        else
            check_previous="$(2>/dev/null ls -a ${backup_path}* |egrep '\.bak[0-9]*' 2> /dev/null)"
            if [ -n "$check_previous" ]; then
                check_num=$(echo "$check_previous" |wc -l)
            fi
            num=$(expr $check_num + 1)
            ${sudo_used} cp ${backup_path} ${backup_path}.bak${num}
    fi
}


function docker_inspect() {
#docker inspect with
    if [ -n $(whereis docker |cut -d: -f2 |egrep '/bin|/sbin' |tr -d ' ') ]; then
        if [ -n $(whereis jq |cut -d: -f2 |egrep '/bin|/sbin' |tr -d ' ') ]; then

            local sudo_used=''
            if $(sudo -v); then sudo_used='sudo'; fi

            ${sudo_used} docker inspect "$1" \
            |jq -r '
            .[0] | {
                Id,
                MergedDir: (if .GraphDriver.Data.MergedDir
                    then (.GraphDriver.Data.MergedDir  )
                    else "MergedDir: NOT EXIST"
                end),
                Path,

                Args: (if has("Args")
                    then (.Args |join("\n ") )
                    else "Args: NOT EXIST"
                end),

                RestartCount,
                Restarting: .State.Restarting,
                OOMKilled: .State.OOMKilled,
                Dead: .State.Dead,

                    LogConfig: (if .HostConfig.LogConfig
                        then (.HostConfig.LogConfig )
                        else "LogConfig: NOT EXIST"
                    end),

                    NetworkMode: (if .HostConfig.NetworkMode
                        then (.HostConfig.NetworkMode )
                        else "NetworkMode: NOT EXIST"
                    end),

                NetworkSettings: (if .NetworkSettings
                    then (.NetworkSettings  )
                    else "NetworkSettings: NOT EXIST"
                end),

                    Labels: (if .Config.Labels
                        then (.Config.Labels  )
                        else "Labels: NOT EXIST"
                    end),

                    PortBindings: (if .HostConfig.PortBindings
                        then (.HostConfig.PortBindings )
                        else "PortBindings: NOT EXIST"
                    end),

                Health: (if has(".State.Health")
                    then (.State.Health |join("\n ") )
                    else "Health: NOT EXIST"
                end),

                    RestartPolicy: (if .HostConfig.RestartPolicy
                        then (.HostConfig.RestartPolicy )
                        else "RestartPolicy: NOT EXIST"
                    end),
                    CapAdd: (if .HostConfig.CapAdd
                        then (.HostConfig.CapAdd )
                        else "CapAdd: NOT EXIST"
                    end),
                    CapDrop: (if .HostConfig.CapDrop
                        then (.HostConfig.CapDrop )
                        else "CapDrop: NOT EXIST"
                    end),
                    CgroupnsMode: (if .HostConfig.CgroupnsMode
                        then (.HostConfig.CgroupnsMode )
                        else "CgroupnsMode: NOT EXIST"
                    end),
                    Cgroup: (if .HostConfig.Cgroup
                        then (.HostConfig.Cgroup )
                        else "Cgroup: NOT EXIST"
                    end),
                    CgroupParent: (if .HostConfig.CgroupParent
                        then (.HostConfig.CgroupParent )
                        else "CgroupParent: NOT EXIST"
                    end),
                    Dns: (if .HostConfig.Dns
                        then (.HostConfig.Dns )
                        else "Dns: NOT EXIST"
                    end),
                    DnsOptions: (if .HostConfig.DnsOptions
                        then (.HostConfig.DnsOptions )
                        else "DnsOptions: NOT EXIST"
                    end),
                    DnsSearch: (if .HostConfig.DnsSearch
                        then (.HostConfig.DnsSearch )
                        else "DnsSearch: NOT EXIST"
                    end),
                    Memory: (if .HostConfig.Memory
                        then (.HostConfig.Memory )
                        else "Memory: NOT EXIST"
                    end),
                    MemorySwap: (if .HostConfig.MemorySwap
                        then (.HostConfig.MemorySwap )
                        else "MemorySwap: NOT EXIST"
                    end),
                    OomKillDisable: (if .HostConfig.OomKillDisable
                        then (.HostConfig.LogConfig )
                        else "LogConfig: NOT EXIST"
                    end),
                    PidsLimit: (if .HostConfig.PidsLimit
                        then (.HostConfig.PidsLimit )
                        else "PidsLimit: NOT EXIST"
                    end),
                    Ulimits: (if .HostConfig.Ulimits
                        then (.HostConfig.Ulimits )
                        else "Ulimits: NOT EXIST"
                    end),
                    Runtime: (if .HostConfig.Runtime
                        then (.HostConfig.Runtime )
                        else "Runtime: NOT EXIST"
                    end),
                    Binds: (if .HostConfig.Binds
                        then (.HostConfig.Binds )
                        else "Binds: NOT EXIST"
                    end),

                Mounts: (if .Mounts
                    then (.Mounts  )
                    else "Mounts: NOT EXIST"
                end),

                    Image: (if .Config.Image
                        then (.Config.Image  )
                        else "Image: NOT EXIST"
                    end),
                    ExposedPorts: (if .Config.ExposedPorts
                        then (.Config.ExposedPorts )
                        else "ExposedPorts: NOT EXIST"
                    end),
                    Domainname: (if .Config.Domainname
                        then (.Config.Domainname )
                        else "Domainname: NOT EXIST"
                    end),
                    User: (if .Config.User
                        then (.Config.User  )
                        else "User: NOT EXIST"
                    end),
                    AttachStdin: (if .Config.AttachStdin
                        then (.Config.AttachStdin  )
                        else "AttachStdin: NOT EXIST"
                    end),
                    AttachStdout: (if .Config.AttachStdout
                        then (.Config.AttachStdout  )
                        else "AttachStdout: NOT EXIST"
                    end),
                    AttachStderr: (if .Config.AttachStderr
                        then (.Config.AttachStderr  )
                        else "AttachStderr: NOT EXIST"
                    end),
                    Env: (if .Config.Env
                        then (.Config.Env  )
                        else "Env: NOT EXIST"
                    end),
                    Cmd: (if .Config.Cmd
                        then (.Config.Cmd  )
                        else "Cmd: NOT EXIST"
                    end),
                    Healthcheck: (if .Config.Healthcheck
                        then (.Config.Healthcheck  )
                        else "Healthcheck: NOT EXIST"
                    end),
                    Volumes: (if .Config.Volumes
                        then (.Config.Volumes  )
                        else "Volumes: NOT EXIST"
                    end),
                    WorkingDir: (if .Config.WorkingDir
                        then (.Config.WorkingDir  )
                        else "WorkingDir: NOT EXIST"
                    end),
                    Entrypoint: (if .Config.Entrypoint
                        then (.Config.Entrypoint  )
                        else "Entrypoint: NOT EXIST"
                    end),

            }
            | if has("Restarting") then . else . + {Restarting: "NOT EXIST"} end
            | tostring
            ' \
            |jq |grep -v 'NOT EXIST'

        fi
    fi

}

function docker_log() {
#docker inspect log output
    if [ -n $(whereis docker |cut -d: -f2 |egrep '/bin|/sbin' |tr -d ' ') ]; then
        if [ -n $(whereis jq |cut -d: -f2 |egrep '/bin|/sbin' |tr -d ' ') ]; then

            local sudo_used=''
            if $(sudo -v); then sudo_used='sudo'; fi

            ${sudo_used} docker inspect "$1" \
            | jq -r '.[0].State.Health.Log[].Output'

            echo -e "==================== LOGS for ${1} =====================: \n\n"
            ${sudo_used} docker logs --details -f "$1"
        fi
    fi
}

docker_exec() {
#docker exec to container
    if [ -n $(whereis docker |cut -d: -f2 |egrep '/bin|/sbin' |tr -d ' ') ]; then
        if [ -n $(whereis jq |cut -d: -f2 |egrep '/bin|/sbin' |tr -d ' ') ]; then

            local sudo_used=''
            if $(sudo -v); then sudo_used='sudo'; fi

            ${sudo_used} docker exec -it $1 zsh  || \
            ${sudo_used} docker exec -it $1 bash || \
            ${sudo_used} docker exec -it $1 ash  || \
            ${sudo_used} docker exec -it $1 sh
        fi
    fi

}

cat_z () {
    local path_logs="${2:-.}"
    local pattern="$1"
    local sudo_used=''
    local type_log=''

    if [[ $EUID -ne 0 ]]; then
        if $(sudo -v);
            then sudo_used='sudo'
        fi
    fi

    ${sudo_used} find "$path_logs" -type f -name "$pattern" -print0 |while IFS= read -r -d $'\0' log_file; do
        type_log="$( ${sudo_used} file $log_file |cut -d ':' -f2 |cut -d ',' -f1)"

        case "$type_log" in
            *ASCII*) archive_cat="cat" ;;
            *gzip*)  archive_cat="zcat" ;;
            *XZ*)    archive_cat="xzcat" ;;
            *bzip2*) archive_cat="bzcat" ;;
            *lzip*)  archive_cat="lzcat" ;;
            *)       archive_cat="cat" ;;
        esac

        ${sudo_used} ${archive_cat} "$log_file"
    done
}



myfunctions_aliases () {
    echo -e '
HIGHLIGHTS HISTORY SEARCH:
        hi                  - search with #tag-
        hh                  - search pattern
        hhall               - search all pattern
        hhistory            - search all and highlight
        hhuniq              - search all uniq pattern
        hhnumuniq           - search all uniq pattern with number
        hhlastuniq          - search tail uniq pattern
        hhlastuniq-grep     - search uniq include grep and set number tail
        hhistory-uniq       - searh hithlight uniq include grep
        history-uniq

SYSTEMD:
        sys-start
        sys-stop
        sys-reload
        sys-stat
        sys-list
        sys-sock
        sys-cat
        sys-edit
        sys-enable
        sys-disable
        sysstopstart

PERMANCE CHECK:
        check_mem
        check_mem_humanreadable
        check_mem_procent
        check_swap
        allcrontab                  - show all crons

DISK SIZE CHECK:
        checkSizeInDirWithIgnore    - check size in cur dir with ignore
        used                        - check size in current dir
        showfatindir

NET CHECK:
        ports                       - show all ports listening
        ports4, ports6
        cmyip, ip_a

SEARCH:
        removeComments      - cat and remove comments
        egreplessdir        - grep -ir
        egrepless           - grep -i
        psaux, psu, psg
        dirtree, stripcomments
        show_new_files
        show_changed_files

DOCKER:
        docker_all
        docker_ports-with_names
        docker_ports-with_id
        docker_names
        docker_status
        docker_images
        docker_exec
        docker_log
        docker_inspect

SYNC:
       scpresume

HIGHLIGHTS:
        gulimit             - highlight ulimit
        gconfigure          - highlight configure
        cconfigure          - highlight configure
        mmake               - highlight make
        ccolorex            - color error...
        diffFiles           - color diff
        err                 - grep -i error...

HIGHLIGHTS grc:
        blkid_g
        ...

GIT SHORCUTS:
        gs, gb, gbv, gp, ga, gl, gd, gdc, glf
        gr, gpo, gplo, gst

OTHER:
        incognito
        extract cat_z
        defcat              - /usr/bin/cat
        scriptformat        - remove ansci unprintable cahracters
        se                  - short sudo
        sq, plz, sr, l1
        maketar
        makezip
        cht                 - search in cheat.sh
        vime, svi
        wdownload, lnn
        xsc, lnn
        lla, lss
        scrd, mounts, supdate
        sprunge, phpinfo_e
        speedt, speedt1, speeddown
        locru, locen, lessr

    '
}
